"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high@0.7.5";
exports.ids = ["vendor-chunks/sugar-high@0.7.5"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/sugar-high@0.7.5/node_modules/sugar-high/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/sugar-high@0.7.5/node_modules/sugar-high/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\n\nconst jsxBrackets = new Set(['<', '>', '{', '}', '[', ']'])\nconst keywords = new Set([\n  'for',\n  'do',\n  'while',\n  'if',\n  'else',\n  'return',\n  'function',\n  'var',\n  'let',\n  'const',\n  'true',\n  'false',\n  'undefined',\n  'this',\n  'new',\n  'delete',\n  'typeof',\n  'in',\n  'instanceof',\n  'void',\n  'break',\n  'continue',\n  'switch',\n  'case',\n  'default',\n  'throw',\n  'try',\n  'catch',\n  'finally',\n  'debugger',\n  'with',\n  'yield',\n  'async',\n  'await',\n  'class',\n  'extends',\n  'super',\n  'import',\n  'export',\n  'from',\n  'static',\n])\n\nconst signs = new Set([\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '=',\n  '!',\n  '&',\n  '|',\n  '^',\n  '~',\n  '!',\n  '?',\n  ':',\n  '.',\n  ',',\n  ';',\n  `'`,\n  '\"',\n  '.',\n  '(',\n  ')',\n  '[',\n  ']',\n  '#',\n  '@',\n  '\\\\',\n  ...jsxBrackets,\n])\n\n\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */\nconst types = /** @type {const} */ ([\n  'identifier',\n  'keyword',\n  'string',\n  'class',\n  'property',\n  'entity',\n  'jsxliterals',\n  'sign',\n  'comment',\n  'break',\n  'space',\n])\nconst [\n  T_IDENTIFIER,\n  T_KEYWORD,\n  T_STRING,\n  T_CLS_NUMBER,\n  T_PROPERTY,\n  T_ENTITY,\n  T_JSX_LITERALS,\n  T_SIGN,\n  T_COMMENT,\n  T_BREAK,\n  T_SPACE,\n] = /** @types {const} */ types.map((_, i) => i)\n\nfunction isSpaces(str) {\n  return /^[^\\S\\r\\n]+$/g.test(str)\n}\n\nfunction isSign(ch) {\n  return signs.has(ch)\n}\n\nfunction encode(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n}\n\nfunction isWord(chr) {\n  return /^[\\w_]+$/.test(chr) || hasUnicode(chr)\n}\n\nfunction isCls(str) {\n  const chr0 = str[0]\n  return isWord(chr0) &&\n    chr0 === chr0.toUpperCase() ||\n    str === 'null'\n}\n\nfunction hasUnicode(s) {\n  return /[^\\u0000-\\u007f]/.test(s);\n}\n\nfunction isAlpha(chr) {\n  return /^[a-zA-Z]$/.test(chr)\n}\n\nfunction isIdentifierChar(chr) {\n  return isAlpha(chr) || hasUnicode(chr)\n}\n\nfunction isIdentifier(str) {\n  return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)))\n}\n\nfunction isStrTemplateChr(chr) {\n  return chr === '`'\n}\n\nfunction isSingleQuotes(chr) {\n  return chr === '\"' || chr === \"'\"\n}\n\nfunction isStringQuotation(chr) {\n  return isSingleQuotes(chr) || isStrTemplateChr(chr)\n}\n\nfunction isCommentStart(str) {\n  str = str.slice(0, 2)\n  return str === '//' || str === '/*'\n}\n\nfunction isRegexStart(str) {\n  return str[0] === '/' && !isCommentStart(str[0] + str[1])\n}\n\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */\nfunction tokenize(code) {\n  let current = ''\n  let type = -1\n  /** @type {[number, string]} */\n  let last = [-1, '']\n  /** @type {[number, string]} */\n  let beforeLast = [-2, '']\n  /** @type {Array<[number, string]>} */\n  const tokens = []\n\n  /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */\n  let __jsxEnter = false\n  /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/\n  let __jsxTag = 0\n  let __jsxExpr = false\n\n  // only match paired (open + close) tags, not self-closing tags\n  let __jsxStack = 0\n  const __jsxChild = () => __jsxEnter && !__jsxExpr && !__jsxTag\n  // < __content__ >\n  const inJsxTag = () => __jsxTag && !__jsxChild()\n  // {'__content__'}\n  const inJsxLiterals = () => !__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0\n\n  /** @type {string | null} */\n  let __strQuote = null\n  let __regexQuoteStart = false\n  let __strTemplateExprStack = 0\n  let __strTemplateQuoteStack = 0\n  const inStringQuotes = () => __strQuote !== null\n  const inRegexQuotes = () => __regexQuoteStart\n  const inStrTemplateLiterals = () => (__strTemplateQuoteStack > __strTemplateExprStack)\n  const inStrTemplateExpr = () => __strTemplateQuoteStack > 0 && (__strTemplateQuoteStack === __strTemplateExprStack)\n  const inStringContent = () => inStringQuotes() || inStrTemplateLiterals()\n\n  /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */\n  function classify(token) {\n    const isLineBreak = token === '\\n'\n    // First checking if they're attributes values\n    if (inJsxTag()) {\n      if (inStringQuotes()) {\n        return T_STRING\n      }\n\n      const [, lastToken] = last\n      if (isIdentifier(token)) {\n        // classify jsx open tag\n        if ((lastToken === '<' || lastToken === '</')) \n          return T_ENTITY\n      }\n    }\n    // Then determine if they're jsx literals\n    const isJsxLiterals = inJsxLiterals()\n    if (isJsxLiterals) return T_JSX_LITERALS\n\n    // Determine strings first before other types\n    if (inStringQuotes()) {\n      return T_STRING\n    } else if (keywords.has(token)) {\n      return last[1] === '.' ? T_IDENTIFIER : T_KEYWORD\n    } else if (isLineBreak) {\n      return T_BREAK\n    } else if (isSpaces(token)) {\n      return T_SPACE\n    } else if (token.split('').every(isSign)) {\n      return T_SIGN\n    } else if (isCls(token)) {\n      return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER\n    } else {\n      if (isIdentifier(token)) {\n        const isLastPropDot = last[1] === '.' && isIdentifier(beforeLast[1])\n\n        if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER\n        if (isLastPropDot) return T_PROPERTY\n      }\n      return T_STRING\n    }\n  }\n\n  /**\n   * \n   * @param {number} type_ \n   * @param {string} token_ \n   */\n  const append = (type_, token_) => {\n    if (type_ || token_) {\n      const nType = types[type_]\n    }\n    if (token_) {\n      current = token_\n    }\n    if (current) {\n      type = type_ || classify(current)\n      /** @type [number, string]  */\n      const pair = [type, current]\n      if (type !== T_SPACE && type !== T_BREAK) {\n        beforeLast = last\n        last = pair\n      }\n      tokens.push(pair)\n    }\n    current = ''\n  }\n  for (let i = 0; i < code.length; i++) {\n    const curr = code[i]\n    const prev = code[i - 1]\n    const next = code[i + 1]\n    const p_c = prev + curr // previous and current\n    const c_n = curr + next // current and next\n\n    // Determine string quotation outside of jsx literals.\n    // Inside jsx literals, string quotation is still part of it.\n    if (isSingleQuotes(curr) && !inJsxLiterals()) {\n      append()\n      if (prev !== `\\\\`) {\n        if (__strQuote && curr === __strQuote) {\n          __strQuote = null\n        } else if (!__strQuote) {\n          __strQuote = curr\n        }\n      }\n\n      append(T_STRING, curr)\n      continue\n    }\n\n    if (!inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        append()\n        append(T_STRING, curr)\n        __strTemplateQuoteStack++\n        continue\n      }\n    }\n\n    if (inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        if (__strTemplateQuoteStack > 0) {\n          append()\n          __strTemplateQuoteStack--\n          append(T_STRING, curr)\n          continue\n        }\n      }\n\n      if (c_n === '${') {\n        __strTemplateExprStack++\n        append(T_STRING)\n        append(T_SIGN, c_n)\n        i++\n        continue\n      }\n    }\n\n    if (inStrTemplateExpr() && curr === '}') {\n      append()\n      __strTemplateExprStack--\n      append(T_SIGN, curr)\n      continue\n    }\n\n    if (__jsxChild()) {\n      if (curr === '{') {\n        append()\n        append(T_SIGN, curr)\n        __jsxExpr = true\n        continue\n      }\n    }\n\n    if (__jsxEnter) {\n      // <: open tag sign\n      // new '<' not inside jsx\n      if (!__jsxTag && curr === '<') {\n        append()\n        if (next === '/') {\n          // close tag\n          __jsxTag = 2\n          current = c_n\n          i++\n        } else {\n          // open tag\n          __jsxTag = 1\n          current = curr\n        }\n        append(T_SIGN)\n        continue\n      }\n      if (__jsxTag) {\n        // >: open tag close sign or closing tag closing sign\n        // and it's not `=>` or `/>`\n        // `curr` could be `>` or `/`\n        if ((curr === '>' && !'/='.includes(prev))) {\n          append()\n          if (__jsxTag === 1) {\n            __jsxTag = 0\n            __jsxStack++\n          } else {\n            __jsxTag = 0\n            __jsxEnter = false\n          }\n          append(T_SIGN, curr)\n          continue\n        }\n\n        // >: tag self close sign or close tag sign\n        if (c_n === '/>' || c_n === '</') {\n          // if current token is not part of close tag sign, push it first\n          if (current !== '<' && current !== '/') {\n            append()\n          }\n\n          if (c_n === '/>') {\n            __jsxTag = 0\n          } else {\n            // is '</'\n            __jsxStack--\n          }\n\n          if (!__jsxStack)\n            __jsxEnter = false\n\n          current = c_n\n          i++\n          append(T_SIGN)\n          continue\n        }\n\n        // <: open tag sign\n        if (curr === '<') {\n          append()\n          current = curr\n          append(T_SIGN)\n          continue\n        }\n\n        // jsx property\n        // `-` in data-prop\n        if (next === '-'  && !inStringContent() && !inJsxLiterals()) {\n          if (current) {\n            append(T_PROPERTY, current + curr + next)\n            i += 1\n            continue\n          }\n        }\n        // `=` in property=<value>\n        if (next === '=' && !inStringContent()) {\n          // if current is not a space, ensure `prop` is a property\n          if (isSpaces(current)) {\n            append(T_SPACE, current)\n            current = ''\n          }\n          const prop = current ? (current + curr) : curr\n          if (isIdentifier(prop)) {\n            current = prop\n            append(T_PROPERTY)\n          }\n          continue\n        }\n      }\n    }\n\n    // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n    if (!__jsxTag && (curr === '<' && isIdentifierChar(next) || c_n === '</')) {\n      __jsxTag = next === '/' ? 2 : 1\n\n      // current and next char can form a jsx open or close tag\n      if (curr === '<' && (next === '/' || isAlpha(next))) {\n        if (\n          !inStringContent() && \n          !inJsxLiterals() &&\n          !inRegexQuotes()\n        ) {\n          __jsxEnter = true\n        }\n      }\n    }\n\n    const isQuotationChar = isStringQuotation(curr)\n    const isStringTemplateLiterals = inStrTemplateLiterals()\n    const isRegexChar = !__jsxEnter && isRegexStart(c_n)\n    const isJsxLiterals = inJsxLiterals()\n\n    // string quotation\n    if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n      current += curr\n    } else if (isRegexChar) {\n      append()\n      const [lastType, lastToken] = last\n      // Special cases that are not considered as regex:\n      // * (expr1) / expr2: `)` before `/` operator is still in expression\n      // * <non comment start>/ expr: non comment start before `/` is not regex\n      if (\n        isRegexChar &&\n        lastType !== -1 &&\n        !(\n          (lastType === T_SIGN && ')' !== lastToken) ||\n          lastType === T_COMMENT\n        )\n      ) {\n        current = curr\n        append()\n        continue\n      }\n\n      __regexQuoteStart = true\n      const start = i++\n\n      // end of line of end of file\n      const isEof = () => i >= code.length\n      const isEol = () => isEof() || code[i] === '\\n'\n\n      let foundClose = false\n      \n      // traverse to find closing regex slash\n      for (; !isEol(); i++) {\n        if (code[i] === '/' && code[i - 1] !== '\\\\') {\n          foundClose = true\n          // end of regex, append regex flags\n          while (start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()) {\n            i++\n          }\n          break\n        }\n      }\n      __regexQuoteStart = false\n\n      if (start !== i && foundClose) {\n        // If current line is fully closed with string quotes or regex slashes,\n        // add them to tokens\n        current = code.slice(start, i + 1)\n        append(T_STRING)\n      } else {\n        // If it doesn't match any of the above, just leave it as operator and move on\n        current = curr\n        append()\n        i = start\n      }\n    } else if (isCommentStart(c_n)) {\n      append()\n      const start = i\n      if (next === '/') {\n        for (; i < code.length && code[i] !== '\\n'; i++);\n      } else {\n        for (; i < code.length && code[i - 1] + code[i] !== '*/'; i++);\n      }\n      current = code.slice(start, i + 1)\n      append(T_COMMENT)\n    } else if (curr === ' ' || curr === '\\n') {\n      if (\n        curr === ' ' &&\n        (\n          (isSpaces(current) || !current) ||\n          isJsxLiterals\n        )\n      ) {\n        current += curr\n        if (next === '<') {\n          append()\n        }\n      } else {\n        append()\n        current = curr\n        append()\n      }\n    } else {\n      if (__jsxExpr && curr === '}') {\n        append()\n        current = curr\n        append()\n        __jsxExpr = false\n      } else if (\n        // it's jsx literals and is not a jsx bracket\n        (isJsxLiterals && !jsxBrackets.has(curr)) ||\n        // same type char as previous one in current token\n        ((isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr))\n      ) {\n        current += curr\n      } else {\n        if (p_c === '</') {\n          current = p_c\n        }\n        append()\n\n        if (p_c !== '</') {\n          current = curr\n\n        }\n        if ((c_n === '</' || c_n === '/>')) {\n          current = c_n\n          append()\n          i++\n        }\n        else if (jsxBrackets.has(curr)) append()\n      }\n    }\n  }\n\n  append()\n\n  return tokens\n}\n\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<any>}\n */\nfunction generate(tokens) {\n  const lines = []\n  /**\n   * @param {any} children\n   * @return {{type: string, tagName: string, children: any[], properties: Record<string, string>}}\n   */\n  const createLine = (children) => \n      ({\n        type: 'element',\n        tagName: 'span',\n        children,\n        properties: {\n          className: 'sh__line',\n        },\n      })\n\n  /**\n   * @param {Array<[number, string]>} tokens\n   * @returns {void}\n   */\n  function flushLine(tokens) {\n    /** @type {Array<any>} */\n    const lineTokens = (\n      tokens\n        .map(([type, value]) => (\n          {\n            type: 'element',\n            tagName: 'span',\n            children: [{\n              type: 'text',\n              value: value, // to encode\n            }],\n            properties: {\n              className: `sh__token--${types[type]}`,\n              style: `color: var(--sh-${types[type]})`,\n            },\n          }\n        ))\n    )\n    lines.push(createLine(lineTokens))\n  }\n  /** @type {Array<[number, string]>} */\n  const lineTokens = []\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    const [type, value] = token\n    if (type !== T_BREAK) {\n      // Divide multi-line token into multi-line code\n      if (value.includes('\\n')) {\n        const lines = value.split('\\n')\n        for (let j = 0; j < lines.length; j++) {\n          lineTokens.push([type, lines[j]])\n          if (j < lines.length - 1) {\n            flushLine(lineTokens)\n            lineTokens.length = 0\n          }\n        }\n      } else {\n        lineTokens.push(token)\n      }\n    } else {\n      lineTokens.push([type, ''])\n      flushLine(lineTokens)\n      lineTokens.length = 0\n    }\n  }\n\n  if (lineTokens.length)\n    flushLine(lineTokens)\n\n  return lines\n}\n\nfunction toHtml(lines) {\n  return lines\n    .map(line => {\n      const { tagName: lineTag } = line\n      const tokens = line.children\n        .map(child => {\n          const { tagName, children, properties } = child\n          return `<${tagName} class=\"${\n            properties.className\n          }\" style=\"${\n            properties.style\n          }\">${encode(children[0].value)}</${tagName}>`\n        })\n        .join('')\n      return `<${lineTag} class=\"${line.properties.className}\">${tokens}</${lineTag}>`\n    })\n    .join('\\n')\n}\n\n/**\n *\n * @param {string} code\n * @returns {string}\n */\nfunction highlight(code) {\n  const tokens = tokenize(code)\n  const lines = generate(tokens)\n  const output = toHtml(lines)\n  return output\n}\n\n// namespace\nconst SugarHigh = /** @type {const} */ {\n  TokenTypes: types,\n  TokenMap: new Map(types.map((type, i) => [type, i])),\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc3VnYXItaGlnaEAwLjcuNS9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxRQUFRO0FBQ1IsZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxZQUFZO0FBQ25ELHdDQUF3QyxZQUFZO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXLElBQUksMEJBQTBCLElBQUksUUFBUTtBQUNyRCxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsU0FBUyxTQUFTLDBCQUEwQixJQUFJLE9BQU8sSUFBSSxRQUFRO0FBQ3BGLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBOztBQU9DIiwic291cmNlcyI6WyIvVXNlcnMvdGVybmVyYS9Eb2N1bWVudHMvZ2l0aHViL3dlYnNpdGUvbm9kZV9tb2R1bGVzLy5wbnBtL3N1Z2FyLWhpZ2hAMC43LjUvbm9kZV9tb2R1bGVzL3N1Z2FyLWhpZ2gvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG5jb25zdCBqc3hCcmFja2V0cyA9IG5ldyBTZXQoWyc8JywgJz4nLCAneycsICd9JywgJ1snLCAnXSddKVxuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KFtcbiAgJ2ZvcicsXG4gICdkbycsXG4gICd3aGlsZScsXG4gICdpZicsXG4gICdlbHNlJyxcbiAgJ3JldHVybicsXG4gICdmdW5jdGlvbicsXG4gICd2YXInLFxuICAnbGV0JyxcbiAgJ2NvbnN0JyxcbiAgJ3RydWUnLFxuICAnZmFsc2UnLFxuICAndW5kZWZpbmVkJyxcbiAgJ3RoaXMnLFxuICAnbmV3JyxcbiAgJ2RlbGV0ZScsXG4gICd0eXBlb2YnLFxuICAnaW4nLFxuICAnaW5zdGFuY2VvZicsXG4gICd2b2lkJyxcbiAgJ2JyZWFrJyxcbiAgJ2NvbnRpbnVlJyxcbiAgJ3N3aXRjaCcsXG4gICdjYXNlJyxcbiAgJ2RlZmF1bHQnLFxuICAndGhyb3cnLFxuICAndHJ5JyxcbiAgJ2NhdGNoJyxcbiAgJ2ZpbmFsbHknLFxuICAnZGVidWdnZXInLFxuICAnd2l0aCcsXG4gICd5aWVsZCcsXG4gICdhc3luYycsXG4gICdhd2FpdCcsXG4gICdjbGFzcycsXG4gICdleHRlbmRzJyxcbiAgJ3N1cGVyJyxcbiAgJ2ltcG9ydCcsXG4gICdleHBvcnQnLFxuICAnZnJvbScsXG4gICdzdGF0aWMnLFxuXSlcblxuY29uc3Qgc2lnbnMgPSBuZXcgU2V0KFtcbiAgJysnLFxuICAnLScsXG4gICcqJyxcbiAgJy8nLFxuICAnJScsXG4gICc9JyxcbiAgJyEnLFxuICAnJicsXG4gICd8JyxcbiAgJ14nLFxuICAnficsXG4gICchJyxcbiAgJz8nLFxuICAnOicsXG4gICcuJyxcbiAgJywnLFxuICAnOycsXG4gIGAnYCxcbiAgJ1wiJyxcbiAgJy4nLFxuICAnKCcsXG4gICcpJyxcbiAgJ1snLFxuICAnXScsXG4gICcjJyxcbiAgJ0AnLFxuICAnXFxcXCcsXG4gIC4uLmpzeEJyYWNrZXRzLFxuXSlcblxuXG4vKipcbiAqXG4gKiAwICAtIGlkZW50aWZpZXJcbiAqIDEgIC0ga2V5d29yZFxuICogMiAgLSBzdHJpbmdcbiAqIDMgIC0gQ2xhc3MsIG51bWJlciBhbmQgbnVsbFxuICogNCAgLSBwcm9wZXJ0eVxuICogNSAgLSBlbnRpdHlcbiAqIDYgIC0ganN4IGxpdGVyYWxzXG4gKiA3ICAtIHNpZ25cbiAqIDggIC0gY29tbWVudFxuICogOSAgLSBicmVha1xuICogMTAgLSBzcGFjZVxuICpcbiAqL1xuY29uc3QgdHlwZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnaWRlbnRpZmllcicsXG4gICdrZXl3b3JkJyxcbiAgJ3N0cmluZycsXG4gICdjbGFzcycsXG4gICdwcm9wZXJ0eScsXG4gICdlbnRpdHknLFxuICAnanN4bGl0ZXJhbHMnLFxuICAnc2lnbicsXG4gICdjb21tZW50JyxcbiAgJ2JyZWFrJyxcbiAgJ3NwYWNlJyxcbl0pXG5jb25zdCBbXG4gIFRfSURFTlRJRklFUixcbiAgVF9LRVlXT1JELFxuICBUX1NUUklORyxcbiAgVF9DTFNfTlVNQkVSLFxuICBUX1BST1BFUlRZLFxuICBUX0VOVElUWSxcbiAgVF9KU1hfTElURVJBTFMsXG4gIFRfU0lHTixcbiAgVF9DT01NRU5ULFxuICBUX0JSRUFLLFxuICBUX1NQQUNFLFxuXSA9IC8qKiBAdHlwZXMge2NvbnN0fSAqLyB0eXBlcy5tYXAoKF8sIGkpID0+IGkpXG5cbmZ1bmN0aW9uIGlzU3BhY2VzKHN0cikge1xuICByZXR1cm4gL15bXlxcU1xcclxcbl0rJC9nLnRlc3Qoc3RyKVxufVxuXG5mdW5jdGlvbiBpc1NpZ24oY2gpIHtcbiAgcmV0dXJuIHNpZ25zLmhhcyhjaClcbn1cblxuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jylcbn1cblxuZnVuY3Rpb24gaXNXb3JkKGNocikge1xuICByZXR1cm4gL15bXFx3X10rJC8udGVzdChjaHIpIHx8IGhhc1VuaWNvZGUoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0NscyhzdHIpIHtcbiAgY29uc3QgY2hyMCA9IHN0clswXVxuICByZXR1cm4gaXNXb3JkKGNocjApICYmXG4gICAgY2hyMCA9PT0gY2hyMC50b1VwcGVyQ2FzZSgpIHx8XG4gICAgc3RyID09PSAnbnVsbCdcbn1cblxuZnVuY3Rpb24gaGFzVW5pY29kZShzKSB7XG4gIHJldHVybiAvW15cXHUwMDAwLVxcdTAwN2ZdLy50ZXN0KHMpO1xufVxuXG5mdW5jdGlvbiBpc0FscGhhKGNocikge1xuICByZXR1cm4gL15bYS16QS1aXSQvLnRlc3QoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNocikge1xuICByZXR1cm4gaXNBbHBoYShjaHIpIHx8IGhhc1VuaWNvZGUoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoc3RyKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKHN0clswXSkgJiYgKHN0ci5sZW5ndGggPT09IDEgfHwgaXNXb3JkKHN0ci5zbGljZSgxKSkpXG59XG5cbmZ1bmN0aW9uIGlzU3RyVGVtcGxhdGVDaHIoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09ICdgJ1xufVxuXG5mdW5jdGlvbiBpc1NpbmdsZVF1b3RlcyhjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gJ1wiJyB8fCBjaHIgPT09IFwiJ1wiXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nUXVvdGF0aW9uKGNocikge1xuICByZXR1cm4gaXNTaW5nbGVRdW90ZXMoY2hyKSB8fCBpc1N0clRlbXBsYXRlQ2hyKGNocilcbn1cblxuZnVuY3Rpb24gaXNDb21tZW50U3RhcnQoc3RyKSB7XG4gIHN0ciA9IHN0ci5zbGljZSgwLCAyKVxuICByZXR1cm4gc3RyID09PSAnLy8nIHx8IHN0ciA9PT0gJy8qJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4U3RhcnQoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0gPT09ICcvJyAmJiAhaXNDb21tZW50U3RhcnQoc3RyWzBdICsgc3RyWzFdKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcmV0dXJuIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoY29kZSkge1xuICBsZXQgY3VycmVudCA9ICcnXG4gIGxldCB0eXBlID0gLTFcbiAgLyoqIEB0eXBlIHtbbnVtYmVyLCBzdHJpbmddfSAqL1xuICBsZXQgbGFzdCA9IFstMSwgJyddXG4gIC8qKiBAdHlwZSB7W251bWJlciwgc3RyaW5nXX0gKi9cbiAgbGV0IGJlZm9yZUxhc3QgPSBbLTIsICcnXVxuICAvKiogQHR5cGUge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuXG4gIC8qKiBAdHlwZSBib29sZWFuIGlmIGVudGVyZWQganN4IHRhZywgaW5zaWRlIDxvcGVuIHRhZz4gb3IgPC9jbG9zZSB0YWc+ICovXG4gIGxldCBfX2pzeEVudGVyID0gZmFsc2VcbiAgLyoqXG4gICAqIEB0eXBlIHswIHwgMSB8IDJ9XG4gICAqIEBleGFtcGxlXG4gICAqIDAgZm9yIG5vdCBpbiBqc3g7XG4gICAqIDEgZm9yIG9wZW4ganN4IHRhZztcbiAgICogMiBmb3IgY2xvc2luZyBqc3ggdGFnO1xuICAgKiovXG4gIGxldCBfX2pzeFRhZyA9IDBcbiAgbGV0IF9fanN4RXhwciA9IGZhbHNlXG5cbiAgLy8gb25seSBtYXRjaCBwYWlyZWQgKG9wZW4gKyBjbG9zZSkgdGFncywgbm90IHNlbGYtY2xvc2luZyB0YWdzXG4gIGxldCBfX2pzeFN0YWNrID0gMFxuICBjb25zdCBfX2pzeENoaWxkID0gKCkgPT4gX19qc3hFbnRlciAmJiAhX19qc3hFeHByICYmICFfX2pzeFRhZ1xuICAvLyA8IF9fY29udGVudF9fID5cbiAgY29uc3QgaW5Kc3hUYWcgPSAoKSA9PiBfX2pzeFRhZyAmJiAhX19qc3hDaGlsZCgpXG4gIC8vIHsnX19jb250ZW50X18nfVxuICBjb25zdCBpbkpzeExpdGVyYWxzID0gKCkgPT4gIV9fanN4VGFnICYmIF9fanN4Q2hpbGQoKSAmJiAhX19qc3hFeHByICYmIF9fanN4U3RhY2sgPiAwXG5cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuICBsZXQgX19zdHJRdW90ZSA9IG51bGxcbiAgbGV0IF9fcmVnZXhRdW90ZVN0YXJ0ID0gZmFsc2VcbiAgbGV0IF9fc3RyVGVtcGxhdGVFeHByU3RhY2sgPSAwXG4gIGxldCBfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA9IDBcbiAgY29uc3QgaW5TdHJpbmdRdW90ZXMgPSAoKSA9PiBfX3N0clF1b3RlICE9PSBudWxsXG4gIGNvbnN0IGluUmVnZXhRdW90ZXMgPSAoKSA9PiBfX3JlZ2V4UXVvdGVTdGFydFxuICBjb25zdCBpblN0clRlbXBsYXRlTGl0ZXJhbHMgPSAoKSA9PiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiBfX3N0clRlbXBsYXRlRXhwclN0YWNrKVxuICBjb25zdCBpblN0clRlbXBsYXRlRXhwciA9ICgpID0+IF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gMCAmJiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPT09IF9fc3RyVGVtcGxhdGVFeHByU3RhY2spXG4gIGNvbnN0IGluU3RyaW5nQ29udGVudCA9ICgpID0+IGluU3RyaW5nUXVvdGVzKCkgfHwgaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKClcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjbGFzc2lmeSh0b2tlbikge1xuICAgIGNvbnN0IGlzTGluZUJyZWFrID0gdG9rZW4gPT09ICdcXG4nXG4gICAgLy8gRmlyc3QgY2hlY2tpbmcgaWYgdGhleSdyZSBhdHRyaWJ1dGVzIHZhbHVlc1xuICAgIGlmIChpbkpzeFRhZygpKSB7XG4gICAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICAgIH1cblxuICAgICAgY29uc3QgWywgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIC8vIGNsYXNzaWZ5IGpzeCBvcGVuIHRhZ1xuICAgICAgICBpZiAoKGxhc3RUb2tlbiA9PT0gJzwnIHx8IGxhc3RUb2tlbiA9PT0gJzwvJykpIFxuICAgICAgICAgIHJldHVybiBUX0VOVElUWVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVuIGRldGVybWluZSBpZiB0aGV5J3JlIGpzeCBsaXRlcmFsc1xuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcbiAgICBpZiAoaXNKc3hMaXRlcmFscykgcmV0dXJuIFRfSlNYX0xJVEVSQUxTXG5cbiAgICAvLyBEZXRlcm1pbmUgc3RyaW5ncyBmaXJzdCBiZWZvcmUgb3RoZXIgdHlwZXNcbiAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgfSBlbHNlIGlmIChrZXl3b3Jkcy5oYXModG9rZW4pKSB7XG4gICAgICByZXR1cm4gbGFzdFsxXSA9PT0gJy4nID8gVF9JREVOVElGSUVSIDogVF9LRVlXT1JEXG4gICAgfSBlbHNlIGlmIChpc0xpbmVCcmVhaykge1xuICAgICAgcmV0dXJuIFRfQlJFQUtcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2VzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIFRfU1BBQ0VcbiAgICB9IGVsc2UgaWYgKHRva2VuLnNwbGl0KCcnKS5ldmVyeShpc1NpZ24pKSB7XG4gICAgICByZXR1cm4gVF9TSUdOXG4gICAgfSBlbHNlIGlmIChpc0Nscyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBpbkpzeFRhZygpID8gVF9JREVOVElGSUVSIDogVF9DTFNfTlVNQkVSXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdFByb3BEb3QgPSBsYXN0WzFdID09PSAnLicgJiYgaXNJZGVudGlmaWVyKGJlZm9yZUxhc3RbMV0pXG5cbiAgICAgICAgaWYgKCFpblN0cmluZ0NvbnRlbnQoKSAmJiAhaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfSURFTlRJRklFUlxuICAgICAgICBpZiAoaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfUFJPUEVSVFlcbiAgICAgIH1cbiAgICAgIHJldHVybiBUX1NUUklOR1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGVfIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5fIFxuICAgKi9cbiAgY29uc3QgYXBwZW5kID0gKHR5cGVfLCB0b2tlbl8pID0+IHtcbiAgICBpZiAodHlwZV8gfHwgdG9rZW5fKSB7XG4gICAgICBjb25zdCBuVHlwZSA9IHR5cGVzW3R5cGVfXVxuICAgIH1cbiAgICBpZiAodG9rZW5fKSB7XG4gICAgICBjdXJyZW50ID0gdG9rZW5fXG4gICAgfVxuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICB0eXBlID0gdHlwZV8gfHwgY2xhc3NpZnkoY3VycmVudClcbiAgICAgIC8qKiBAdHlwZSBbbnVtYmVyLCBzdHJpbmddICAqL1xuICAgICAgY29uc3QgcGFpciA9IFt0eXBlLCBjdXJyZW50XVxuICAgICAgaWYgKHR5cGUgIT09IFRfU1BBQ0UgJiYgdHlwZSAhPT0gVF9CUkVBSykge1xuICAgICAgICBiZWZvcmVMYXN0ID0gbGFzdFxuICAgICAgICBsYXN0ID0gcGFpclxuICAgICAgfVxuICAgICAgdG9rZW5zLnB1c2gocGFpcilcbiAgICB9XG4gICAgY3VycmVudCA9ICcnXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VyciA9IGNvZGVbaV1cbiAgICBjb25zdCBwcmV2ID0gY29kZVtpIC0gMV1cbiAgICBjb25zdCBuZXh0ID0gY29kZVtpICsgMV1cbiAgICBjb25zdCBwX2MgPSBwcmV2ICsgY3VyciAvLyBwcmV2aW91cyBhbmQgY3VycmVudFxuICAgIGNvbnN0IGNfbiA9IGN1cnIgKyBuZXh0IC8vIGN1cnJlbnQgYW5kIG5leHRcblxuICAgIC8vIERldGVybWluZSBzdHJpbmcgcXVvdGF0aW9uIG91dHNpZGUgb2YganN4IGxpdGVyYWxzLlxuICAgIC8vIEluc2lkZSBqc3ggbGl0ZXJhbHMsIHN0cmluZyBxdW90YXRpb24gaXMgc3RpbGwgcGFydCBvZiBpdC5cbiAgICBpZiAoaXNTaW5nbGVRdW90ZXMoY3VycikgJiYgIWluSnN4TGl0ZXJhbHMoKSkge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGlmIChwcmV2ICE9PSBgXFxcXGApIHtcbiAgICAgICAgaWYgKF9fc3RyUXVvdGUgJiYgY3VyciA9PT0gX19zdHJRdW90ZSkge1xuICAgICAgICAgIF9fc3RyUXVvdGUgPSBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoIV9fc3RyUXVvdGUpIHtcbiAgICAgICAgICBfX3N0clF1b3RlID0gY3VyclxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFpblN0clRlbXBsYXRlTGl0ZXJhbHMoKSkge1xuICAgICAgaWYgKHByZXYgIT09ICdcXFxcbicgJiYgaXNTdHJUZW1wbGF0ZUNocihjdXJyKSkge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICAgIF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKCkpIHtcbiAgICAgIGlmIChwcmV2ICE9PSAnXFxcXG4nICYmIGlzU3RyVGVtcGxhdGVDaHIoY3VycikpIHtcbiAgICAgICAgaWYgKF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gMCkge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2stLVxuICAgICAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjX24gPT09ICckeycpIHtcbiAgICAgICAgX19zdHJUZW1wbGF0ZUV4cHJTdGFjaysrXG4gICAgICAgIGFwcGVuZChUX1NUUklORylcbiAgICAgICAgYXBwZW5kKFRfU0lHTiwgY19uKVxuICAgICAgICBpKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5TdHJUZW1wbGF0ZUV4cHIoKSAmJiBjdXJyID09PSAnfScpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBfX3N0clRlbXBsYXRlRXhwclN0YWNrLS1cbiAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChfX2pzeENoaWxkKCkpIHtcbiAgICAgIGlmIChjdXJyID09PSAneycpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgICAgX19qc3hFeHByID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfX2pzeEVudGVyKSB7XG4gICAgICAvLyA8OiBvcGVuIHRhZyBzaWduXG4gICAgICAvLyBuZXcgJzwnIG5vdCBpbnNpZGUganN4XG4gICAgICBpZiAoIV9fanN4VGFnICYmIGN1cnIgPT09ICc8Jykge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBpZiAobmV4dCA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gY2xvc2UgdGFnXG4gICAgICAgICAgX19qc3hUYWcgPSAyXG4gICAgICAgICAgY3VycmVudCA9IGNfblxuICAgICAgICAgIGkrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG9wZW4gdGFnXG4gICAgICAgICAgX19qc3hUYWcgPSAxXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKF9fanN4VGFnKSB7XG4gICAgICAgIC8vID46IG9wZW4gdGFnIGNsb3NlIHNpZ24gb3IgY2xvc2luZyB0YWcgY2xvc2luZyBzaWduXG4gICAgICAgIC8vIGFuZCBpdCdzIG5vdCBgPT5gIG9yIGAvPmBcbiAgICAgICAgLy8gYGN1cnJgIGNvdWxkIGJlIGA+YCBvciBgL2BcbiAgICAgICAgaWYgKChjdXJyID09PSAnPicgJiYgIScvPScuaW5jbHVkZXMocHJldikpKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBpZiAoX19qc3hUYWcgPT09IDEpIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgICAgX19qc3hTdGFjaysrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgICAgX19qc3hFbnRlciA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vID46IHRhZyBzZWxmIGNsb3NlIHNpZ24gb3IgY2xvc2UgdGFnIHNpZ25cbiAgICAgICAgaWYgKGNfbiA9PT0gJy8+JyB8fCBjX24gPT09ICc8LycpIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRva2VuIGlzIG5vdCBwYXJ0IG9mIGNsb3NlIHRhZyBzaWduLCBwdXNoIGl0IGZpcnN0XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09ICc8JyAmJiBjdXJyZW50ICE9PSAnLycpIHtcbiAgICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNfbiA9PT0gJy8+Jykge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzICc8LydcbiAgICAgICAgICAgIF9fanN4U3RhY2stLVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX19qc3hTdGFjaylcbiAgICAgICAgICAgIF9fanN4RW50ZXIgPSBmYWxzZVxuXG4gICAgICAgICAgY3VycmVudCA9IGNfblxuICAgICAgICAgIGkrK1xuICAgICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDw6IG9wZW4gdGFnIHNpZ25cbiAgICAgICAgaWYgKGN1cnIgPT09ICc8Jykge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBqc3ggcHJvcGVydHlcbiAgICAgICAgLy8gYC1gIGluIGRhdGEtcHJvcFxuICAgICAgICBpZiAobmV4dCA9PT0gJy0nICAmJiAhaW5TdHJpbmdDb250ZW50KCkgJiYgIWluSnN4TGl0ZXJhbHMoKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBhcHBlbmQoVF9QUk9QRVJUWSwgY3VycmVudCArIGN1cnIgKyBuZXh0KVxuICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBgPWAgaW4gcHJvcGVydHk9PHZhbHVlPlxuICAgICAgICBpZiAobmV4dCA9PT0gJz0nICYmICFpblN0cmluZ0NvbnRlbnQoKSkge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgaXMgbm90IGEgc3BhY2UsIGVuc3VyZSBgcHJvcGAgaXMgYSBwcm9wZXJ0eVxuICAgICAgICAgIGlmIChpc1NwYWNlcyhjdXJyZW50KSkge1xuICAgICAgICAgICAgYXBwZW5kKFRfU1BBQ0UsIGN1cnJlbnQpXG4gICAgICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJvcCA9IGN1cnJlbnQgPyAoY3VycmVudCArIGN1cnIpIDogY3VyclxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXIocHJvcCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBwcm9wXG4gICAgICAgICAgICBhcHBlbmQoVF9QUk9QRVJUWSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm90IGluIGEganN4IHRhZyBkZWNsYXJhdGlvbiBvciBhIHN0cmluZywgY2xvc2UgY2hpbGQgaWYgbmV4dCBpcyBqc3ggY2xvc2UgdGFnXG4gICAgaWYgKCFfX2pzeFRhZyAmJiAoY3VyciA9PT0gJzwnICYmIGlzSWRlbnRpZmllckNoYXIobmV4dCkgfHwgY19uID09PSAnPC8nKSkge1xuICAgICAgX19qc3hUYWcgPSBuZXh0ID09PSAnLycgPyAyIDogMVxuXG4gICAgICAvLyBjdXJyZW50IGFuZCBuZXh0IGNoYXIgY2FuIGZvcm0gYSBqc3ggb3BlbiBvciBjbG9zZSB0YWdcbiAgICAgIGlmIChjdXJyID09PSAnPCcgJiYgKG5leHQgPT09ICcvJyB8fCBpc0FscGhhKG5leHQpKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluU3RyaW5nQ29udGVudCgpICYmIFxuICAgICAgICAgICFpbkpzeExpdGVyYWxzKCkgJiZcbiAgICAgICAgICAhaW5SZWdleFF1b3RlcygpXG4gICAgICAgICkge1xuICAgICAgICAgIF9fanN4RW50ZXIgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc1F1b3RhdGlvbkNoYXIgPSBpc1N0cmluZ1F1b3RhdGlvbihjdXJyKVxuICAgIGNvbnN0IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyA9IGluU3RyVGVtcGxhdGVMaXRlcmFscygpXG4gICAgY29uc3QgaXNSZWdleENoYXIgPSAhX19qc3hFbnRlciAmJiBpc1JlZ2V4U3RhcnQoY19uKVxuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcblxuICAgIC8vIHN0cmluZyBxdW90YXRpb25cbiAgICBpZiAoaXNRdW90YXRpb25DaGFyIHx8IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyB8fCBpc1NpbmdsZVF1b3RlcyhfX3N0clF1b3RlKSkge1xuICAgICAgY3VycmVudCArPSBjdXJyXG4gICAgfSBlbHNlIGlmIChpc1JlZ2V4Q2hhcikge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGNvbnN0IFtsYXN0VHlwZSwgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIC8vIFNwZWNpYWwgY2FzZXMgdGhhdCBhcmUgbm90IGNvbnNpZGVyZWQgYXMgcmVnZXg6XG4gICAgICAvLyAqIChleHByMSkgLyBleHByMjogYClgIGJlZm9yZSBgL2Agb3BlcmF0b3IgaXMgc3RpbGwgaW4gZXhwcmVzc2lvblxuICAgICAgLy8gKiA8bm9uIGNvbW1lbnQgc3RhcnQ+LyBleHByOiBub24gY29tbWVudCBzdGFydCBiZWZvcmUgYC9gIGlzIG5vdCByZWdleFxuICAgICAgaWYgKFxuICAgICAgICBpc1JlZ2V4Q2hhciAmJlxuICAgICAgICBsYXN0VHlwZSAhPT0gLTEgJiZcbiAgICAgICAgIShcbiAgICAgICAgICAobGFzdFR5cGUgPT09IFRfU0lHTiAmJiAnKScgIT09IGxhc3RUb2tlbikgfHxcbiAgICAgICAgICBsYXN0VHlwZSA9PT0gVF9DT01NRU5UXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBfX3JlZ2V4UXVvdGVTdGFydCA9IHRydWVcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaSsrXG5cbiAgICAgIC8vIGVuZCBvZiBsaW5lIG9mIGVuZCBvZiBmaWxlXG4gICAgICBjb25zdCBpc0VvZiA9ICgpID0+IGkgPj0gY29kZS5sZW5ndGhcbiAgICAgIGNvbnN0IGlzRW9sID0gKCkgPT4gaXNFb2YoKSB8fCBjb2RlW2ldID09PSAnXFxuJ1xuXG4gICAgICBsZXQgZm91bmRDbG9zZSA9IGZhbHNlXG4gICAgICBcbiAgICAgIC8vIHRyYXZlcnNlIHRvIGZpbmQgY2xvc2luZyByZWdleCBzbGFzaFxuICAgICAgZm9yICg7ICFpc0VvbCgpOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVbaV0gPT09ICcvJyAmJiBjb2RlW2kgLSAxXSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgZm91bmRDbG9zZSA9IHRydWVcbiAgICAgICAgICAvLyBlbmQgb2YgcmVnZXgsIGFwcGVuZCByZWdleCBmbGFnc1xuICAgICAgICAgIHdoaWxlIChzdGFydCAhPT0gaSAmJiAvXlthLXpdJC8udGVzdChjb2RlW2kgKyAxXSkgJiYgIWlzRW9sKCkpIHtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX3JlZ2V4UXVvdGVTdGFydCA9IGZhbHNlXG5cbiAgICAgIGlmIChzdGFydCAhPT0gaSAmJiBmb3VuZENsb3NlKSB7XG4gICAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpcyBmdWxseSBjbG9zZWQgd2l0aCBzdHJpbmcgcXVvdGVzIG9yIHJlZ2V4IHNsYXNoZXMsXG4gICAgICAgIC8vIGFkZCB0aGVtIHRvIHRva2Vuc1xuICAgICAgICBjdXJyZW50ID0gY29kZS5zbGljZShzdGFydCwgaSArIDEpXG4gICAgICAgIGFwcGVuZChUX1NUUklORylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSBhYm92ZSwganVzdCBsZWF2ZSBpdCBhcyBvcGVyYXRvciBhbmQgbW92ZSBvblxuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBpID0gc3RhcnRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ29tbWVudFN0YXJ0KGNfbikpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBjb25zdCBzdGFydCA9IGlcbiAgICAgIGlmIChuZXh0ID09PSAnLycpIHtcbiAgICAgICAgZm9yICg7IGkgPCBjb2RlLmxlbmd0aCAmJiBjb2RlW2ldICE9PSAnXFxuJzsgaSsrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgY29kZS5sZW5ndGggJiYgY29kZVtpIC0gMV0gKyBjb2RlW2ldICE9PSAnKi8nOyBpKyspO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGNvZGUuc2xpY2Uoc3RhcnQsIGkgKyAxKVxuICAgICAgYXBwZW5kKFRfQ09NTUVOVClcbiAgICB9IGVsc2UgaWYgKGN1cnIgPT09ICcgJyB8fCBjdXJyID09PSAnXFxuJykge1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyID09PSAnICcgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChpc1NwYWNlcyhjdXJyZW50KSB8fCAhY3VycmVudCkgfHxcbiAgICAgICAgICBpc0pzeExpdGVyYWxzXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgICAgaWYgKG5leHQgPT09ICc8Jykge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfX2pzeEV4cHIgJiYgY3VyciA9PT0gJ30nKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIF9fanN4RXhwciA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBpdCdzIGpzeCBsaXRlcmFscyBhbmQgaXMgbm90IGEganN4IGJyYWNrZXRcbiAgICAgICAgKGlzSnN4TGl0ZXJhbHMgJiYgIWpzeEJyYWNrZXRzLmhhcyhjdXJyKSkgfHxcbiAgICAgICAgLy8gc2FtZSB0eXBlIGNoYXIgYXMgcHJldmlvdXMgb25lIGluIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgKChpc1dvcmQoY3VycikgPT09IGlzV29yZChjdXJyZW50W2N1cnJlbnQubGVuZ3RoIC0gMV0pIHx8IF9fanN4Q2hpbGQoKSkgJiYgIXNpZ25zLmhhcyhjdXJyKSlcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwX2MgPT09ICc8LycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcF9jXG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKClcblxuICAgICAgICBpZiAocF9jICE9PSAnPC8nKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcblxuICAgICAgICB9XG4gICAgICAgIGlmICgoY19uID09PSAnPC8nIHx8IGNfbiA9PT0gJy8+JykpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc3hCcmFja2V0cy5oYXMoY3VycikpIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKClcblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gdG9rZW5zXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZSh0b2tlbnMpIHtcbiAgY29uc3QgbGluZXMgPSBbXVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGNoaWxkcmVuXG4gICAqIEByZXR1cm4ge3t0eXBlOiBzdHJpbmcsIHRhZ05hbWU6IHN0cmluZywgY2hpbGRyZW46IGFueVtdLCBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fX1cbiAgICovXG4gIGNvbnN0IGNyZWF0ZUxpbmUgPSAoY2hpbGRyZW4pID0+IFxuICAgICAgKHtcbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnc2hfX2xpbmUnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gdG9rZW5zXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gZmx1c2hMaW5lKHRva2Vucykge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi9cbiAgICBjb25zdCBsaW5lVG9rZW5zID0gKFxuICAgICAgdG9rZW5zXG4gICAgICAgIC5tYXAoKFt0eXBlLCB2YWx1ZV0pID0+IChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIC8vIHRvIGVuY29kZVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogYHNoX190b2tlbi0tJHt0eXBlc1t0eXBlXX1gLFxuICAgICAgICAgICAgICBzdHlsZTogYGNvbG9yOiB2YXIoLS1zaC0ke3R5cGVzW3R5cGVdfSlgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgICkpXG4gICAgKVxuICAgIGxpbmVzLnB1c2goY3JlYXRlTGluZShsaW5lVG9rZW5zKSlcbiAgfVxuICAvKiogQHR5cGUge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSAqL1xuICBjb25zdCBsaW5lVG9rZW5zID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXVxuICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSB0b2tlblxuICAgIGlmICh0eXBlICE9PSBUX0JSRUFLKSB7XG4gICAgICAvLyBEaXZpZGUgbXVsdGktbGluZSB0b2tlbiBpbnRvIG11bHRpLWxpbmUgY29kZVxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHZhbHVlLnNwbGl0KCdcXG4nKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGluZVRva2Vucy5wdXNoKFt0eXBlLCBsaW5lc1tqXV0pXG4gICAgICAgICAgaWYgKGogPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmbHVzaExpbmUobGluZVRva2VucylcbiAgICAgICAgICAgIGxpbmVUb2tlbnMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVRva2Vucy5wdXNoKHRva2VuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9rZW5zLnB1c2goW3R5cGUsICcnXSlcbiAgICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuICAgICAgbGluZVRva2Vucy5sZW5ndGggPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxpbmVUb2tlbnMubGVuZ3RoKVxuICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuXG4gIHJldHVybiBsaW5lc1xufVxuXG5mdW5jdGlvbiB0b0h0bWwobGluZXMpIHtcbiAgcmV0dXJuIGxpbmVzXG4gICAgLm1hcChsaW5lID0+IHtcbiAgICAgIGNvbnN0IHsgdGFnTmFtZTogbGluZVRhZyB9ID0gbGluZVxuICAgICAgY29uc3QgdG9rZW5zID0gbGluZS5jaGlsZHJlblxuICAgICAgICAubWFwKGNoaWxkID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRhZ05hbWUsIGNoaWxkcmVuLCBwcm9wZXJ0aWVzIH0gPSBjaGlsZFxuICAgICAgICAgIHJldHVybiBgPCR7dGFnTmFtZX0gY2xhc3M9XCIke1xuICAgICAgICAgICAgcHJvcGVydGllcy5jbGFzc05hbWVcbiAgICAgICAgICB9XCIgc3R5bGU9XCIke1xuICAgICAgICAgICAgcHJvcGVydGllcy5zdHlsZVxuICAgICAgICAgIH1cIj4ke2VuY29kZShjaGlsZHJlblswXS52YWx1ZSl9PC8ke3RhZ05hbWV9PmBcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJycpXG4gICAgICByZXR1cm4gYDwke2xpbmVUYWd9IGNsYXNzPVwiJHtsaW5lLnByb3BlcnRpZXMuY2xhc3NOYW1lfVwiPiR7dG9rZW5zfTwvJHtsaW5lVGFnfT5gXG4gICAgfSlcbiAgICAuam9pbignXFxuJylcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodChjb2RlKSB7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGNvZGUpXG4gIGNvbnN0IGxpbmVzID0gZ2VuZXJhdGUodG9rZW5zKVxuICBjb25zdCBvdXRwdXQgPSB0b0h0bWwobGluZXMpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLy8gbmFtZXNwYWNlXG5jb25zdCBTdWdhckhpZ2ggPSAvKiogQHR5cGUge2NvbnN0fSAqLyB7XG4gIFRva2VuVHlwZXM6IHR5cGVzLFxuICBUb2tlbk1hcDogbmV3IE1hcCh0eXBlcy5tYXAoKHR5cGUsIGkpID0+IFt0eXBlLCBpXSkpLFxufVxuXG5leHBvcnQge1xuICBoaWdobGlnaHQsXG4gIHRva2VuaXplLFxuICBnZW5lcmF0ZSxcbiAgU3VnYXJIaWdoLFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sugar-high@0.7.5/node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;